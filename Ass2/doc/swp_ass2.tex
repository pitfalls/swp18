
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the  LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[12pt,runningheads,a4paper]{llncs}


\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage[mathcal]{eucal}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{mathtools}

\usepackage{array}
\usepackage{amsmath}
\usepackage{float}
\usepackage{soul}





\usepackage{listings}
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\lstset{
    literate={~} {$\sim$}{1}
}



\makeatletter
\renewcommand\chapter{\thispagestyle{plain}%
\global\@topnum\z@
\@afterindentfalse
\secdef\@chapter\@schapter}
\makeatother
\urldef{\mailsa}\path|alexander.frewein@student.tugraz.at|
\urldef{\mailsf}\path|fabian.fruehwirth@student.tugraz.at|
\urldef{\mailsp}\path|stephany.amizic@student.tugraz.at|
\topmargin-0.5cm


\begin{document}


% first the title is needed
\title{SWP Assignment 1}

% a short form should be given in case it is too long for the running head
\titlerunning{SWP Assignment 1}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Alexander Frewein (01430019)\\
		Klaus Fabian Frühwirt (01131523)\\
		Stephany Amizic (01331786)}

%
\authorrunning{SWP Assigmnment 1}
% (feature abused for this document to repeat the title also on left hand pages)
% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Institute of Software Technology\\
\mailsa \\
\mailsf \\
\mailsp \\
}




\toctitle{SWP Assignment 1}
\tocauthor{Authors' Instructions}
\maketitle




\bigskip
\bigskip
\section*{Beispiel 1}
\begin{lstlisting}[language=scala]
def div(a: Int, b:Int): Int = a / b
def mod(a: Int, b:Int): Int = a % b
\end{lstlisting}

\section*{Beispiel 3}
\subsection*{a}
Gehen wir mal davon aus dass \textsf{x1 = [ [ [] ] ]}  \\
das wäre eine Verschachtelungstiefe von 3\\
Wir würden dann der\textsf{max(build(depth(first(x1)), nil), depth(rest(x1))) das x1 mit einer Verschachtelungstiefe von 4 übergeben, welches mit der funktion build erzeugt wird und x2 mit einer Tiefe von 3 welche durch 
Dann rufen wir depth(x1) auf.\\
Das würde bedeuten dass bei depth:\\
\textsf{if atom?(first(x1)) = F}\\ 
\textsf{else if eq?(x1, nil) = F} und es wird im else Zweig:\\
} ausgeführt\\
\textsf{depth(first(x1))} wird in unserem Fall dann durch textsf{ else if eq?(x1, nil) = T} zu \textsf{nil}.\\
$\rightarrow$  \textsf{max(build(nil, nil), depth(rest(x1)))},  \textsf{depth(rest(x1))} wird ebenfalls zu \textsf{nil}, jedoch mit einer Verschachtelungstiefe von 1. Das \textsf{build(nil, nil)} baut eine Liste mit einer Verschachtelungstiefe von 2.\\
Dann wird Funktion max aufgerufen:\\
\textsf{if eq?(x1, nil) = T}\\
Das bedeutet es wird die Verschachtelungstiefe von x2 returned wird. X2 hat jedoch eine Verschachtelungstiefe von 1 und x1 jedoch von 2, was bedeutet dass in diesem Fall die Funktion max den falschen Wert zurückgibt.
\newpage

\subsection*{b}
$\omega(\underline{x1}) = [[a]]$\\
$I(\delta, \omega, \underline{depth(x1)}) \\
=I(\delta, \omega, \underline{if \, atom?(first(x1)) \, then \, depth(rest(x))}\\
\underline{else \, if \, eq?(x1,nil) \, then \, nil} \\
\underline{else \, max(build(depth(first(x)),\,nil),\, depth(rest(x)))})\\
\\
NR: I(\delta, \omega, \underline{atom?(first(x1))}) = atom?(I(\delta, \omega, \underline{first(x1))}) = atom?(first(I(\delta, \omega, \underline{x1}))) \\ 
= atom?(first([])) = atom?([]) = F \\
\\
=I(\delta, \omega, \underline{if \, eq?(x1, nil)\, then \, nil}) \\
\\
NR:I(\delta, \omega, \underline{if \, eq?(x1, nil) then \, nil}) = if \, eq?(I(\delta, \omega \underline{x1}, nil)) = if \, eq?([[a]], nil) = F\\
\\
$


\section*{Beispiel 4}
\begin{lstlisting}[language=scala]
    def count(needle:Int, haystack: List[Int]) : Int = haystack match{
          case Nil => 0
          case x::xs if(x == needle) => 1 + countName(x, xs)
          case x::xs if(x != needle) => 0
} 
\end{lstlisting}

\subsection*{Hypothese:}
count(append(as, bs), e) == count(as, e) + count(bs, e)
\subsection*{Induktions Basis:   as = Nil}
count(append(as, bs), e) == count(as, e) + count(bs, e)\\
count(append(nil, bs), e) == count(nil, e) + count(bs, e)\\
count(bs, e) == 0 + count(bs,e)\\
count(bs,e) == count(bs,e)


\subsection*{Induktions Schritt:   as = a::as}
count(append(a::as, bs), e) == count(a::as, e) + count(bs, e)\\
count(a::append(as, bs), e) == count(a::as, e) + count(bs, e)\\
count(a::as, e) + count(bs, e) == count(a::as, e) + count(bs, e)\\ 
count(a, e) + count(as, e) + count(bs, e) == count(a, e) + count(as, e) + count(bs,e) $\rightarrow$ q.e.d.

\end{document}

